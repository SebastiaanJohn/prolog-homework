/*
Read Chapter 3 ‘Working with numbers’ and Appendix A ‘Recursive programming’ from the Lecture NotesPreview the document.
Solve Exercise 2.10 from the Lecture Notes (unary arithmetic).
Solve Exercise 3.17 from Bratko’s book (maximum of a list).
Solve Exercise 3.2 from the Lecture Notes (printing a square).
Solve Exercise 3.5 from the Lecture Notes (extracting an element from a list).
Solve Exercise 3.9 from the Lecture Notes (people database).
*/

% 2.10
% a)
successor([], [x]). % basecase
successor([H|T], [x, H|T]). % everyother case
    
% b)
plus([], [], []) :- % basecase
    !.

plus(Ls1, Ls2, Result) :- % othercases
    append(Ls1, Ls2, Result).


% c)
times([], _, []) :-
    !.

times(_, [], []) :-
    !.

times([_|T], Ls, Result) :-
    append(Ls, Result, Result2),
    times(T, Ls, Result2).