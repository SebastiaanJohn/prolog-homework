% % s([[c,a,b], [], []], Solution).
% s(Stacks, [Stack1, [Top1|Stack2], OtherStacks]) :-
%     del([Top1|Stack1], Stacks, Stacks1),
%     del(Stack2, Stacks1, OtherStacks).

% del(X, [X|L], L).

% del(X, [Y|L], [Y|L1]) :-
%     del(X, L, L1).


% move function of blockworld
move(Stacks, NewStacks) :-
    select([Top|Stack1], Stacks, Rest),
    select(Stack2, Rest, OtherStacks),
    NewStacks=[Stack1, [Top|Stack2]|OtherStacks].

% goal function of blockworld
goal(Stacks) :-
    member([a, b, c], Stacks).

% depthfirst
% ?- solve_depthfirst([[c,b,a],[],[]], Plan).
solve_depthfirst(Node, [Node|Path]) :-
    depthfirst(Node, Path).

depthfirst(Node, []) :-
    goal(Node).

depthfirst(Node, [NextNode|Path]) :-
    move(Node, NextNode),
    depthfirst(NextNode, Path).

% loopfree version of depth first
move_cyclefree(Visited, Node, NextNode) :-
    move(Node, NextNode),
    \+ member(NextNode, Visited).

solve_depthfirst_cyclefree(Node, Path) :-
    depthfirst_cyclefree([Node], Node, RevPath),
    reverse(RevPath, Path).

depthfirst_cyclefree(Visited, Node, Visited) :-
    goal(Node).

depthfirst_cyclefree(Visited, Node, Path) :-
    move_cyclefree(Visited, Node, NextNode),
    depthfirst_cyclefree([NextNode|Visited], NextNode, Path).

check(Rel, A, B) :-
    Goal=..[Rel, A, B], % Goal becomes Rel(A, B)
    call(Goal). % calls predicate Rel(A, B)
insertsort(_, [], []).

% insertsort
insertsort(Rel, [X|Tail], Sorted) :-
    insertsort(Rel, Tail, SortedTail),
    insert(Rel, X, SortedTail, Sorted).

insert(Rel, X, [Y|Sorted], [Y|Sorted1]) :-
    check(Rel, Y, X),
    !,
    insert(Rel, X, Sorted, Sorted1).

insert(_, X, Sorted, [X|Sorted]).